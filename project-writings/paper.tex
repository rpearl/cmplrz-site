\documentclass{article}
\usepackage{fullpage}
%\usepackage{times}
\usepackage{url}
\usepackage{amsmath,amsthm,amssymb,color}
%\usepackage{multicol}
\usepackage{float}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
%\usepackage[all]{hypcap}

\newcommand{\Squash}{\mathsf{Squash}}
\newcommand{\Clamp}{\mathsf{Clamp}}
\newcommand{\Range}{\mathsf{Range}}
\let\x\cdot

\begin{document}

\title{\bf Range Analysis for the IonMonkey JavaScript engine}

\author{
Ryan Pearl\\
\texttt{$<$rpearl@andrew.cmu.edu$>$}\\
\and
Michael Sullivan\\
\texttt{$<$mjsulliv@cs.cmu.edu$>$}\\
}

\maketitle

\section{Introduction}
With the explosion of browser based applications that has occured in
recent years, Javascript has become one of the most widely used
programming languages, and Javascript performance has become
critically important. Unfortunately, Javascript seems to be designed
to be un-performant.

One source of these woes are Javascript's dynamic semantics for
numbers: all numeric values are defined by the specification to be
IEEE 754 double precision floating point values (with bitwise
operations being defined to round to the nearest 32 bit integer before
performing the operation). Since the common case is that numeric
values are integers and because floating point operations are
more expensive, all major Javascript implementations attempt to
represent numbers as integers when possible.

In IonMonkey, Mozilla's next-generation optimizing Javascript JIT
compiler, an approximate type inference system is used to generate
type-specialized code for the common case of integer arithmetic, and
type guards are inserted if the type inferencer is not certain. The
catch is that since double precision floats have a larger range than
32-bit integers, if the integer operations would overflow the result
must be promoted to being stored in a double. IonMonkey deals with
this by inserting overflow checks after arithmetic operations and
bailing out of the type specialized code if they trip. While this is
sometimes actually necessary, it is frequently the case that overflow
is not possible.

We have implemented integer value range analysis in the IonMonkey
engine and used it to eliminate provably unnecessary overflow checks.
We implemented an SSA-based worklist range analysis algorithm that
propagates integer ranges for variables by performing range
arithmetic. The algorithm is based off of Gough and Klaeren's range
analysis for bounds check elimination
\cite{Gough94eliminatingrange}. A range (including information about
possible overflow) is associated with each computation, and the ranges
are consulted to determine whether to perform overflow checks for
arithmetic computations.

OTHER OPTIMIZATIONS WE DO

OUR CONTRIBUTIONS


\section{Related Work}
%% XXX: FIXME, TODO
We have looked at a few papers on range analysis, such as ``The Design
and Implementation of a Non-Iterative Range Analysis Algorithm on a
Production Compiler'', by Teixeira and Pereira, which is a practical
implementation of an algorithm designed by by Su and Wagner
\cite{Su04aclass}. The algorithm due to Su and Wagner is
non-iterative, and works by solving a constraint graph. Other range
analyses, generally formulated as a more traditional iterative
dataflow problem, are also available.

We reviewed the literature on different types of range analysis and
decided to implement an analysis based on Gough and Klaeren's SSA
based range analysis algorithm \cite{Gough94eliminatingrange}.

\section{IonMonkey Overview}

\begin{figure}[ht]
\begin{eqnarray*}
Z &=& {-\infty} \cup [-2^{31}, 2^{31}-1] \cup {\infty} \\
\Clamp(n) &=& \begin{cases}
-\infty &\text{if } n < -2^{31} \\
\infty &\text{if } n > -2^{31}-1 \\
n&\text{otherwise } \\
\end{cases}\\
\Clamp([l, h]) &=& [\Clamp(l), \Clamp(h)] \\
{[x_l, x_h] \cup [y_l, y_h]} &=& [\min(x_l, y_l), \max(x_h, y_h)] \\
{[x_l, x_h] \cap [y_l, y_h]} &=& [\max(x_l, y_l), \min(x_h, y_h)] \\
{[x_l, x_h] + [y_l, y_h]} &=& \Clamp ([x_l + y_l, x_h + y_h]) \\
{[x_l, x_h] - [y_l, y_h]} &=& \Clamp ([x_l - y_h, x_h + y_l]) \\
{[x_l, x_h] \x [y_l, y_h]} &=& 
\begin{tabular}{rl}
$\Clamp ([$&$\min(x_l \x y_l, x_l \x y_h, x_h \x y_l, x_h \x y_h),$\\
&$\max(x_l \x y_l, x_l \x y_h, x_h \x y_l, x_h \x y_h)])$ \\
\end{tabular}
\end{eqnarray*}

\caption{Range arithmetic definitions}
\label{fig:range_arith}
\end{figure}



\begin{figure}[ht]
\begin{eqnarray*}
\Squash(n) &=& \begin{cases}
 -2^{31} &\text{if } n = -\infty \\
2^{31}-1 &\text{if } n = \infty \\
n&\text{otherwise } \\
\end{cases}\\
\Squash([l, h]) &=& [\Squash(l), \Squash(h)]
\end{eqnarray*}
%
\begin{eqnarray*}
x = \Phi(y, z) &\Rightarrow&
    \Range(x) = \Squash(\Range(y)) \cup \Squash(\Range(z)) \\
x = \beta(y, [l, h]) &\Rightarrow& \Range(x) = \Squash(\Range(y)) \cap [l, h] \\
x = y + z &\Rightarrow& \Range(x) = \Squash(\Range(y)) + \Squash(\Range(z)) \\
x = y - z &\Rightarrow& \Range(x) = \Squash(\Range(y)) - \Squash(\Range(z)) \\
x = y \x z &\Rightarrow& \Range(x) = \Squash(\Range(y)) \x \Squash(\Range(z)) \\
\end{eqnarray*}


\caption{Range analysis equations}
\label{fig:range_anal}
\end{figure}


\section{Implementation}
%% XXX: TODO

\section{Evaluation}
%% XXX: TODO

\section{Surprises and Lessons Learned}
%% XXX: TODO

\section{Conclusions}
%% XXX: TODO
Boy, JS is a pain in the ass.

\bibliography{citations}{}
\bibliographystyle{abbrv}


\end{document}
